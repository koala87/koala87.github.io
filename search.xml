<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F12%2F18%2Fjava-memory%2F</url>
    <content type="text"><![CDATA[了解Java运行时数据区域，几种常见的内存异常；了解垃圾回收原理；了解常见的内存问题分析工具。 运行时数据区域 1、程序计数器如果线程执行的是Java方法，计数器记录的是正在执行的虚拟机字节码地址；如果正在执行的是Native方法，这个计数器值为空（Undefined）。此区域是唯一一个规范里没有规定任何OutOfMemoryError情况的区域。 2、Java虚拟机栈用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）。此区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机允许深度，将抛出StackOverflowError；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够内存，就会抛出OutOfMemoryError。 3、本地方法栈Native Method Stack。有的虚拟机，比如HotSpot，直接将本地方法栈与虚拟机栈合二为一。与虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError。 4、Java堆虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java椎是垃圾收集器管理主要区域，也叫“GC堆”（Garbage Collected Heap）。细分为新生代和老生代；再细致有Eden空间、From Survivor空间、To Survivor空间等。从内存分配角度，线程共享的Java椎中可能分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。 Java堆可以处于物理上不连续的内存，只要逻辑上是连续的即可。 5、方法区存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。HotSpot实现中，把方法区放在“永久代”（Permanent Generation），简化了内存管理，可以像管理堆一样管理这部分内存。规范对方法区限制比较宽松，可以选择不实现垃圾收集。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。 6、运行时常量池Runtime Constant Pool是方法区一部分。会抛出OutOfMemoryError。 7、直接内存JDK1.4中新加入NIO（New Input/Output）类，引入一种基于Channel与Buffer的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 本机直接内存分配不会受到Java堆大小限制，但是肯定还是受到本机内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间限制。会抛出OutOfMemoryError异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper安装部署及基本使用]]></title>
    <url>%2F2018%2F12%2F03%2Fzookeeper-use%2F</url>
    <content type="text"><![CDATA[ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed. Learn more about ZooKeeper on the ZooKeeper Wiki. ZooKeeper是一种维护配置信息，维护命名规则，提供分布式同步和分组的协调服务。分布式系统都或多或少使用了上述功能。独立实现这些功能有很多的工作要做，不可避免得要处理竞争条件等BUG。正因如此，很多应用都很少处理这些，导致了难于变更维护。即使正确实现了功能，不同的实现方式也导致应用在部署时的维护成本。 安装配置目前最新稳定版本是3.4.12，可以从官网下载。 解压并重命名。 123$ cd /opt$ sudo tar zvxf zookeeper-3.4.12.tar.gz$ sudo mv zookeeper-3.4.12 zookeeper 环境变量配置，编辑.bashrc文件，文件末尾加上如下内容。 12export ZOOKEEPER_HOME=/opt/zookeeperexport PATH=$PATH:$ZOOKEEPER_HOME/bin 编辑后，运行以下命令使环境变量生效。 1source ~/.bashrc 修改配置文件 初次使用，需要将conf目录下的zoo_sample.cfg重命名为zoo.cfg，配置如下： 12345678910111213141516171819202122232425262728# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1 配置项目说明如下： tickTime: ZooKeeper 中使用的基本时间单元, 以毫秒为单位, 默认值是 2000。它用来调节心跳和超时。例如, 默认的会话超时时间是两倍的 tickTime。 initLimit: 默认值是 10, 即 tickTime 属性值的 10 倍。它用于配置允许 followers 连接并同步到 leader 的最大时间。如果 ZooKeeper 管理的数据量很大的话可以增加这个值。 syncLimit: 默认值是 5, 即 tickTime 属性值的 5 倍。它用于配置leader 和 followers 间进行心跳检测的最大延迟时间。如果在设置的时间内 followers 无法与 leader 进行通信, 那么 followers 将会被丢弃。 dataDir: ZooKeeper 用来存储内存数据库快照的目录, 并且除非指定其它目录, 否则数据库更新的事务日志也将会存储在该目录下。建议配置 dataLogDir 参数来指定 ZooKeeper 事务日志的存储目录。 clientPort: 服务器监听客户端连接的端口, 也即客户端尝试连接的端口, 默认值是 2181。 maxClientCnxns: 在 socket 级别限制单个客户端与单台服务器之前的并发连接数量, 可以通过 IP 地址来区分不同的客户端。它用来防止某种类型的 DoS 攻击, 包括文件描述符耗尽。默认值是 60。将其设置为 0 将完全移除并发连接数的限制。 autopurge.snapRetainCount: 配置 ZooKeeper 在自动清理的时候需要保留的数据文件快照的数量和对应的事务日志文件, 默认值是 3。 autopurge.purgeInterval: 和参数 autopurge.snapRetainCount 配套使用, 用于配置 ZooKeeper 自动清理文件的频率, 默认值是 1, 即默认开启自动清理功能, 设置为 0 则表示禁用自动清理功能。 单机模式 修改zoo.cfg 1234ticketTime=2000clientPort=2181dataDir=/opt/zookeeper/datadataLogDir=/opt/zookeeper/logs 启动服务 1$ sudo bin/zkServer.sh start 屏幕输出 123ZooKeeper JMX enabled by defaultUsing config: /opt/zookeeper/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 检查服务状态 1$ sudo bin/zkServer.sh status 屏幕输出 123ZooKeeper JMX enabled by defaultUsing config: /opt/zookeeper/bin/../conf/zoo.cfgMode: standalone 停止服务 1$ sudo bin/zkServer.sh stop 屏幕输出 123ZooKeeper JMX enabled by defaultUsing config: /opt/zookeeper/bin/../conf/zoo.cfgStopping zookeeper ... STOPPED 集群模式Zookeeper集群模式最小节点数目为3 (2n+1, n=1时)，主要以下原因： 集群的写操作，由leader节点负责，它会把通知所有节进行写入操作，只有收到半数以上节点的成功反馈，才算成功。如果是部署2个节点的话，那就必须都成功。 选举策略也是需要半数以上的节点同意才能当选leader，如果是偶数节点可能导致票数相同的情况。 只有当半数以上的节点存活时 zookeeper集群才能对外服务，维持正常状态，如果是2个节点，只要其中一个挂掉，那么剩下的1个并不满足半数以上规则。 假设当前三个节点机器，分别是linux1、linux2、linux3。 （非必须，便于后续配置）增加以下内容到3个节点/etc/hosts文件末尾，对应IP分别为三个节点真实IP。 123linux1 192.168.0.1linux2 192.168.0.2linux3 192.168.0.3 修改zoo.cfg，每个节点的zoo.cfg配置相同。 123456789ticketTime=2000clientPort=2181dataDir=/opt/zookeeper/datadataLogDir=/opt/zookeeper/logsinitLimit=10syncLimit=5server.1=linux1:2888:3888server.2=linux2:2888:3888server.3=linux3:2888:3888 创建myid文件，每个节点的myid值不同。 在 dataDir 指定的目录下 (即 /opt/zookeeper/data 目录) 创建名为 myid 的文件, 文件内容和 zoo.cfg 中当前机器的 id 一致。根据上述配置, linux1 的 myid 文件内容为 1，linux2的myid为2，linux3的myid为3。 启动服务 1$ sudo bin/zkServer.sh start 检查服务状态，可以看到一个Master和两个Slave角色。 1$ sudo bin/zkServer.sh status 客户端基本使用通过提供的客户端测试基本功能，包括创建、查询、更改、删除节点，以及quota和ACL操作。 连接客户端 1bin/zkCli.sh -server localhost:2181 1234567891011121314151617181920212223[zk: localhost:2181(CONNECTED) 0] helpZooKeeper -server host:port cmd args stat path [watch] set path data [version] ls path [watch] delquota [-n|-b] path ls2 path [watch] setAcl path acl setquota -n|-b val path history redo cmdno printwatches on|off delete path [version] sync path listquota path rmr path get path [watch] create [-s] [-e] path data acl addauth scheme auth quit getAcl path close connect host:port 创建节点 12[zk: localhost:2181(CONNECTED) 1] create /node1 value1Created /node1 查询节点 12345678910111213[zk: localhost:2181(CONNECTED) 3] get /node1value1cZxid = 0xdctime = Mon Dec 03 21:20:17 CST 2018mZxid = 0xdmtime = Mon Dec 03 21:20:17 CST 2018pZxid = 0xdcversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 6numChildren = 0 列出子节点，类似文件系统ls 1234[zk: localhost:2181(CONNECTED) 4] create /node1/subnode1 subvalue1Created /node1/subnode1[zk: localhost:2181(CONNECTED) 5] ls /node1[subnode1] 修改节点值 12345678910111213141516171819202122232425[zk: localhost:2181(CONNECTED) 6] set /node1 value2cZxid = 0xdctime = Mon Dec 03 21:20:17 CST 2018mZxid = 0xfmtime = Mon Dec 03 21:23:23 CST 2018pZxid = 0xecversion = 1dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 6numChildren = 1[zk: localhost:2181(CONNECTED) 7] get /node1value2cZxid = 0xdctime = Mon Dec 03 21:20:17 CST 2018mZxid = 0xfmtime = Mon Dec 03 21:23:23 CST 2018pZxid = 0xecversion = 1dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 6numChildren = 1 删除节点，其中delete只能删除不含有子节点的节点，rmr可以递归删除节点。 123[zk: localhost:2181(CONNECTED) 9] delete /node1/subnode1[zk: localhost:2181(CONNECTED) 10] ls /node1[] quota操作，对节点增加限制。 12345setquota -n|-b val path n:表示子节点的最大个数 b:表示数据值的最大长度 val:子节点最大个数或数据值的最大长度 path:节点路径 1listquota path 1delquota [-n|-b] path ACL操作。 权限主要有： CREATE : 创建子节点 READ : 获取节点数据和子节点列表 WRITE : 更新节点数据 DELETE : 删除子节点 ADMIN : 设置节点ACL的权限 几个概念： shchema:权限模式,有IP和digest两种 ID:授权对象 permission:权限，指的就是上面所说的五种权限 其他命令，比如history，redo。 1234567891011121314[zk: localhost:2181(CONNECTED) 11] history1 - create /node1 value12 - ls /node13 - get /node14 - create /node1/subnode1 subvalue15 - ls /node16 - set /node1 value27 - get /node18 - delete /node19 - delete /node1/subnode110 - ls /node111 - history[zk: localhost:2181(CONNECTED) 12] redo 10[] SDK基本使用 Java POM文件增加依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.util.List;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooDefs.Ids;import org.apache.zookeeper.ZooKeeper;import org.apache.zookeeper.data.Stat;/** * * @author Harry * */public class ZkSimple &#123; private static final String connectString = &quot;localhost:2181&quot;; private static final int sessionTimeout = 2000; private static ZooKeeper zk = null; public static void main(String[] args) throws Exception &#123; create(); getChildren(); isExist(); getData(); delete(); setData(); &#125; /** * 获取zookeeper实例 * @return * @throws Exception */ public static ZooKeeper getZookeeper() throws Exception &#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; // 收到watch通知后的回调函数 System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath()); //因为监听器只会监听一次，这样可以一直监听,且只监听&quot;/&quot;目录 try &#123; zk.getChildren(&quot;/&quot;, true); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); return zk; &#125; /** * 创建数据 * @throws Exception */ public static void create() throws Exception &#123; ZooKeeper zk = getZookeeper(); //创建一个节点，返回创建好的路径 ，且上传的数据可以为任意类型，需要转换成byte[] //参数1 路径，参数2 内容，参数3 权限，参数4 类型 String znodePath = zk.create(&quot;/mytest&quot;, &quot;hello zookeeper&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); System.out.println(&quot;返回的路径 为：&quot; + znodePath); &#125; /** * 判断znode是否存在 * @throws Exception */ public static void isExist() throws Exception &#123; ZooKeeper zk = getZookeeper(); Stat exists = zk.exists(&quot;/lijie&quot;, false); if (exists == null) &#123; System.out.println(&quot;不存在&quot;); &#125; else &#123; System.out.println(&quot;存在&quot;); &#125; &#125; /** * 获取子节点 * @throws Exception */ public static void getChildren() throws Exception &#123; ZooKeeper zk = getZookeeper(); //获取子节点 List&lt;String&gt; children = zk.getChildren(&quot;/&quot;, true); for (String string : children) &#123; System.out.println(&quot;子节点:&quot; + string); &#125; //阻塞，测试监听器,且只监听&quot;/&quot;目录 Thread.sleep(Long.MAX_VALUE); &#125; /** * 获取znode数据 * @throws Exception */ public static void getData() throws Exception &#123; ZooKeeper zk = getZookeeper(); byte[] data = zk.getData(&quot;/lijie/test&quot;, false, new Stat()); System.out.println(new String(data)); &#125; /** * 删除数据 * @throws Exception */ public static void delete() throws Exception &#123; ZooKeeper zk = getZookeeper(); //第二个参数为version，-1表示删除所有版本 //它不支持删除的节点下面还有子节点，只能递归删除 zk.delete(&quot;/hehe&quot;, -1); &#125; /** * 修改znode的值 * @throws Exception */ public static void setData() throws Exception &#123; ZooKeeper zk = getZookeeper(); //修改znode的值 zk.setData(&quot;/lijie&quot;, &quot;modify data&quot;.getBytes(), -1); //测试是否修改成功 System.out.println(new String(zk.getData(&quot;/lijie&quot;, false, null))); &#125;&#125; Python 安装依赖模块 1$ easy_install kazoo.client 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-import sysfrom kazoo.client import KazooClientdef main(): try: nodePath = &quot;/zktest&quot; host = &quot;localhost&quot; port = &quot;2181&quot; timeout = 100 zkc = KazooClient(hosts=host + &apos;:&apos; + port, timeout=timeout) zkc.start() if zkc.exists(nodePath): print nodePath + &quot; exists&quot; else: result = zkc.create(nodePath, &quot;test111&quot;) print &quot;create node &quot; + result + &quot; ok&quot; dataAndStat = zkc.get(nodePath) data = dataAndStat[0] print &quot;value:&quot; + data stat = dataAndStat[1] print &quot;version:&quot;, stat.version print &quot;length&quot;, stat.data_length print &quot;num of children&quot;, stat.numChildren stat = zkc.set(nodePath, value=&quot;test222&quot;) print &quot;version&quot;, stat.version if zkc.exists(nodePath): zkc.delete(nodePath, recursive=True) if zkc.exists(nodePath): print &quot;delete fail&quot; else: print &apos;delete ok&apos; zkc.stop() zkc.close() except Exception as e: print eif __name__ == &quot;__main__&quot;: main() 参考资料 Apache ZooKeeper官网 ZooKeeper安装和配置 Zookeeper基本命令 通过Python客户端对Zookeeper的基本操作 Java调用Zookeeper API Demo]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
